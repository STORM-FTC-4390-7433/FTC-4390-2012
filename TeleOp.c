#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  HTMotor)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     backRight,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     frontLeft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     frontRight,    tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_2,     backLeft,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     armMotor,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "ProportionalControl.h"
#include "range.h"

#pragma platform(Tetrix)

/* Motor Roles:
 * - MotorA           moves ramp
 * - frontLeftMotor   moves robot, front left wheel
 * - backRightMotor   moves robot, back right wheel
 * - frontRightMotor  moves robot, front right wheel
 * - backLeftMotor    moves robot, back left wheel
 * - MotorH           moves arm up and down
 * - clawServo        moves hand
 */

//#define ENABLE_RAMP
#define ENABLE_ARM
//#define ENABLE_CLAW
//#define COMPETITION

void omniDrive(float x, float y, float scale, float spin);

#ifdef ENABLE_RAMP
void releaseRamp();
#endif

ProportionalSettings armSettings;

#define ARM_MAX_POWER  75
#define ARM_MAX_ERROR  15
#define ARM_KP         2
#define ARM_MIN        0
#define ARM_MAX        720
#define ARM_FINE_RANGE 90

#define DRIVE_NORMAL_SCALE 1
#define DRIVE_SLOW_SCALE   0.5

task main() {
#ifdef COMPETITION
    waitForStart();
#endif
    armSettings.kP        = ARM_KP;
    armSettings.maxError  = ARM_MAX_ERROR;
    armSettings.minOutput = -ARM_MAX_POWER;
    armSettings.maxOutput = ARM_MAX_POWER;

    float armRoughSetpoint = 0,
          armFineSetpoint  = 0;

    while(true) {
        getJoystickSettings(joystick);

        //see if btn 8 is depressed.
        //if so set a scale factor for all movement calculations
        //in omnidrive function
        omniDrive(scaleJoystickValue(-100,100,joystick.joy1_x1),
                  scaleJoystickValue(-100,100,joystick.joy1_y1),
                  joy1Btn(8) ? DRIVE_SLOW_SCALE : DRIVE_NORMAL_SCALE,
                  scaleJoystickValue(-50,50,joystick.joy1_x2));

#ifdef ENABLE_ARM

        if(joy2Btn(5)) {
            armRoughSetpoint = scaleJoystickValue(ARM_MIN,
                                                  ARM_MAX,
                                                  joystick.joy2_y1);
            armFineSetpoint = 0;
        }
        if(joy2Btn(6)) {
            armFineSetpoint = scaleJoystickValue(-ARM_FINE_RANGE,
                                                 ARM_FINE_RANGE,
                                                 joystick.joy2_y2);
        } else {
            armRoughSetpoint += armFineSetpoint;
            armFineSetpoint = 0;
        }

        proportionalControl(armMotor,
                            armSettings,
                            clamp(armRoughSetpoint+armFineSetpoint,
                                  ARM_MIN,
                                  ARM_MAX));

#endif

#ifdef ENABLE_CLAW

        switch(joystick.joy2_TopHat) {
        case 0:
        case 1:
        case 7:
            servo[clawServo] += 0.5;
            break;

        case 5:
        case 4:
        case 3:
            servo[clawServo] += -0.5;
            break;

        default:
            servo[clawServo] = 0;
        }

#endif

#ifdef ENABLE_RAMP

        if(joy1Btn(10) && joy1Btn(9) && joy2Btn(10) && joy2Btn(9)) {
            releaseRamp();
            break;
        }

#endif

    }
    writeDebugStreamLine("Main execution aborted");
}

//float scale: multiplies by the scale factor to receive new speed
void omniDrive(float x, float y, float scale, float spin) {
    int upRightSpeed = (x + y)  / sqrt(2);
    int upLeftSpeed  = (-x + y) / sqrt(2);

    int frontRightSpeed = clamp(upLeftSpeed  - spin,-100,100) * scale,
        frontLeftSpeed  = clamp(upRightSpeed + spin,-100,100) * scale,
        backRightSpeed  = clamp(upRightSpeed - spin,-100,100) * scale,
        backLeftSpeed   = clamp(upLeftSpeed  + spin,-100,100) * scale;

    motor[frontLeft]  = frontLeftSpeed;
    motor[backRight]  = backRightSpeed;
    motor[backLeft]   = backLeftSpeed;
    motor[frontRight] = frontRightSpeed;

    //writeDebugStreamLine("frontRight:%d,frontLeft:%d,backRight:%d,backLeft:%d", frontRightSpeed,frontLeftSpeed,backRightSpeed,backLeftSpeed);
}

#ifdef ENABLE_LATCH

void releaseRamp() {
    writeDebugStreamLine("Ramp release initiated.");
#define LATCH_TARGET 270
#define ARM_TARGET
    int latchEncoder = 0, armEncoder = 0;
    //TODO: test latch release
    while(nMotorEncoder[motorA] < LATCH_TARGET) {
        motor[motorA] = 50;
    }
    motor[motorA] = 0;
    motor[motorH] = 0;
    while (armEncoder < ARM_TARGET - armPos) {
            armEncoder += nMotorEncoder[motorH];
            nMotorEncoder[motorH] = 0;
    }
    motor[motorA] = 0;
    motor[motorH] = 0;
    while (armEncoder < ARM_TARGET - armPos) {
            armEncoder += nMotorEncoder[motorH];
            nMotorEncoder[motorH] = 0;
    }
    writeDebugStreamLine("Latch release completed.");
}

#endif
